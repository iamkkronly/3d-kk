<script>
// ========================
// EXTREME GPU+CPU DOUBLE STRESS
// ========================

// HEAVY Fragment Shader Renderer
const vertexShaderSource = `#version 300 es
in vec4 a_position;
void main() {
  gl_Position = a_position;
}`;
const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 outColor;
uniform float uTime;
void main() {
  vec2 uv = gl_FragCoord.xy / vec2(1024.0);
  float t = uTime;
  
  // Heavy math to destroy GPU
  for (int i = 0; i < 1000; i++) {
    uv = fract(uv * 1.1 + sin(t + length(uv)));
    t += 0.00001;
  }
  
  outColor = vec4(uv, fract(t), 1.0);
}`;

// Create shaders manually
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}
function createProgram(gl, vsSource, fsSource) {
  const program = gl.createProgram();
  const vShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  gl.attachShader(program, vShader);
  gl.attachShader(program, fShader);
  gl.linkProgram(program);
  return program;
}

// New heavy program
const heavyProgram = createProgram(gl, vertexShaderSource, fragmentShaderSource);
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
  -1,  1,
   1, -1,
   1,  1,
]), gl.STATIC_DRAW);

// Add time uniform
const uTimeLoc = gl.getUniformLocation(heavyProgram, "uTime");

// EXTREME Memory Leaks (simulate)
function leakMemory() {
  let arr = [];
  setInterval(() => {
    for (let i = 0; i < 10000; i++) {
      arr.push(new Array(1000).fill(Math.random()));
    }
  }, 10);
}

// NEW render loop
function heavyRender() {
  gl.useProgram(heavyProgram);

  const positionLocation = gl.getAttribLocation(heavyProgram, "a_position");
  gl.enableVertexAttribArray(positionLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  gl.uniform1f(uTimeLoc, performance.now() * 0.001);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  requestAnimationFrame(heavyRender);
}

// Start heavy stress functions
leakMemory();
heavyRender();
</script>
