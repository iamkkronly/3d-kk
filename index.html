<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultimate Rounded Ball - WebGL</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec3 aPosition;
attribute vec3 aColor;
varying vec3 vColor;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform float uTime;

void main(void) {
    vec3 pos = aPosition + 0.1 * vec3(
        sin(uTime + aPosition.x * 10.0),
        cos(uTime + aPosition.y * 10.0),
        sin(uTime + aPosition.z * 10.0)
    );
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(pos, 1.0);
    gl_PointSize = 2.5 + 2.0 * abs(sin(uTime + aPosition.y * 10.0));
    vColor = aColor;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
varying vec3 vColor;

void main(void) {
    float dist = length(gl_PointCoord - vec2(0.5));
    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
    gl_FragColor = vec4(vColor, alpha);
}
</script>

<script src="https://cdn.jsdelivr.net/npm/gl-matrix@2.8.1/dist/gl-matrix-min.js"></script>

<script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if (!gl) {
  alert('WebGL not supported bro! Samsung jaise khatara device ka issue!');
}

function compileShader(id, type) {
  const shaderScript = document.getElementById(id);
  const shader = gl.createShader(type);
  gl.shaderSource(shader, shaderScript.text);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

function createProgram() {
  const vertexShader = compileShader('vertex-shader', gl.VERTEX_SHADER);
  const fragmentShader = compileShader('fragment-shader', gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

const program = createProgram();
gl.useProgram(program);

function generateSpherePoints(radius, numPoints) {
  const vertices = [];
  const colors = [];
  for (let i = 0; i < numPoints; i++) {
    const u = Math.random();
    const v = Math.random();
    const theta = u * 2.0 * Math.PI;
    const phi = Math.acos(2.0 * v - 1.0);
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    vertices.push(x, y, z);
    colors.push(Math.random(), Math.random(), Math.random());
  }
  return {vertices: new Float32Array(vertices), colors: new Float32Array(colors)};
}

let sphere = generateSpherePoints(1.0, 6000);

const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, sphere.vertices, gl.STATIC_DRAW);

const colorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, sphere.colors, gl.STATIC_DRAW);

const aPosition = gl.getAttribLocation(program, 'aPosition');
const aColor = gl.getAttribLocation(program, 'aColor');
const uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
const uTime = gl.getUniformLocation(program, 'uTime');

let startTime = Date.now();

function draw() {
  const time = (Date.now() - startTime) * 0.001;

  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const projectionMatrix = mat4.create();
  mat4.perspective(projectionMatrix, Math.PI/4, aspect, 0.1, 100.0);

  const modelViewMatrix = mat4.create();
  mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -5.0]);
  mat4.rotateY(modelViewMatrix, modelViewMatrix, time * 0.5);
  mat4.rotateX(modelViewMatrix, modelViewMatrix, time * 0.3);

  gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
  gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
  gl.uniform1f(uTime, time);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aPosition);

  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aColor);

  gl.drawArrays(gl.POINTS, 0, sphere.vertices.length/3);

  requestAnimationFrame(draw);
}

gl.clearColor(0, 0, 0, 1);
gl.enable(gl.DEPTH_TEST);

canvas.addEventListener('click', () => {
  // New colors on click - explosion vibe
  let newColors = [];
  for (let i = 0; i < sphere.vertices.length/3; i++) {
    newColors.push(Math.random(), Math.random(), Math.random());
  }
  sphere.colors = new Float32Array(newColors);
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, sphere.colors, gl.STATIC_DRAW);
});

draw();
</script>
</body>
</html>
