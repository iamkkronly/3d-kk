<!DOCTYPE html>
<html>
<head>
    <title>GPU/CPU Stress Test</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #warning {
            position: absolute;
            top: 10px;
            left: 10px;
            color: red;
            font-family: Arial;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="warning">WARNING: Heavy load - May cause system slowdown</div>
    <canvas id="glcanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        precision highp float;
        attribute vec3 position;
        uniform float time;
        uniform mat4 projection;
        uniform mat4 view;
        varying vec3 vColor;

        void main() {
            // Complex 3D fractal transformation
            vec3 p = position;
            for(int i = 0; i < 10; i++) {
                p = abs(p) / dot(p,p) - 0.5;
                p *= 1.1 + sin(time * 0.5) * 0.3;
            }
            
            vColor = vec3(
                0.5 + 0.5 * sin(p.x * 10.0 + time),
                0.5 + 0.5 * sin(p.y * 10.0 + time * 1.3),
                0.5 + 0.5 * sin(p.z * 10.0 + time * 1.7)
            );
            
            gl_Position = projection * view * vec4(p, 1.0);
            gl_PointSize = 3.0 + 2.0 * sin(time + length(p));
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec3 vColor;
        uniform float time;

        void main() {
            // Complex coloring with multiple effects
            float d = length(gl_PointCoord - 0.5);
            float alpha = smoothstep(0.5, 0.0, d);
            
            vec3 color = vColor;
            for(int i = 0; i < 3; i++) {
                color = fract(color * 1.5 + sin(time * 0.3));
            }
            
            gl_FragColor = vec4(color * alpha, alpha);
        }
    </script>

    <script>
        // Warning message
        const warning = document.getElementById('warning');
        setTimeout(() => {
            warning.textContent += " - Running at maximum load!";
        }, 3000);

        // Initialize WebGL
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported!');
            throw new Error('WebGL not supported');
        }

        // Compile shaders
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(document.getElementById('vertex-shader').text, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(document.getElementById('fragment-shader').text, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Generate 1 million points in a sphere
        const numPoints = 1000000;
        const positions = new Float32Array(numPoints * 3);
        
        for (let i = 0; i < numPoints; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = Math.pow(Math.random(), 1/3);
            
            positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = r * Math.cos(phi);
        }

        // Create buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Set up attributes
        const positionAttr = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionAttr);
        gl.vertexAttribPointer(positionAttr, 3, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        const timeUniform = gl.getUniformLocation(program, 'time');
        const projectionUniform = gl.getUniformLocation(program, 'projection');
        const viewUniform = gl.getUniformLocation(program, 'view');

        // Set up matrices
        function updateMatrices() {
            const aspect = canvas.clientWidth / canvas.clientHeight;
            const projection = mat4.create();
            mat4.perspective(projection, Math.PI/3, aspect, 0.1, 100.0);
            
            const view = mat4.create();
            mat4.translate(view, view, [0, 0, -5]);
            mat4.rotateX(view, view, Math.PI/6);
            
            gl.uniformMatrix4fv(projectionUniform, false, projection);
            gl.uniformMatrix4fv(viewUniform, false, view);
        }

        // CPU stress with Web Workers
        function startWorkers() {
            if (window.Worker) {
                const cores = navigator.hardwareConcurrency || 4;
                for (let i = 0; i < cores * 2; i++) {
                    const workerCode = `
                        function heavyMath() {
                            let sum = 0;
                            while(true) {
                                for (let i = 0; i < 1000000; i++) {
                                    sum += Math.sqrt(Math.random() * Math.PI * Math.random());
                                }
                                if (sum > 1e10) sum = 0;
                            }
                        }
                        heavyMath();
                    `;
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    new Worker(URL.createObjectURL(blob));
                }
            }
        }

        // Start everything
        const startTime = Date.now();
        startWorkers();
        
        function render() {
            const time = (Date.now() - startTime) * 0.001;
            
            // Resize canvas
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // Update uniforms
            gl.uniform1f(timeUniform, time);
            updateMatrices();
            
            // Draw
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.drawArrays(gl.POINTS, 0, numPoints);
            
            requestAnimationFrame(render);
        }

        // Enable depth testing
        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0, 0, 0, 1);
        
        // Include gl-matrix for matrix math
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js';
        script.onload = render;
        document.head.appendChild(script);

        // Prevent browser throttling
        document.addEventListener('mousemove', () => {});
        document.addEventListener('keydown', () => {});
    </script>
</body>
</html>
