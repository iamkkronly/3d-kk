<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>⚠️ ULTRA EXTREME GPU/CPU STRESS TEST ⚠️</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
  </style>
</head>
<body>
  <canvas id="canvas1"></canvas>
  <canvas id="canvas2"></canvas>

  <script id="fragment-shader" type="x-shader/x-fragment">
    #version 300 es
    precision highp float;
    uniform float uTime;
    out vec4 fragColor;

    void main() {
      vec2 uv = gl_FragCoord.xy / vec2(1024.0);

      vec3 color = vec3(uv, 0.5);
      for (int i = 0; i < 200; i++) {  // Heavy loop
        color = fract(color * 1.5 + sin(uTime + length(color)));
      }

      fragColor = vec4(color, 1.0);
    }
  </script>

  <script>
    const canvases = [document.getElementById('canvas1'), document.getElementById('canvas2')];
    const glContexts = canvases.map(c => c.getContext('webgl2', { antialias: false }));

    if (glContexts.includes(null)) {
      alert("WebGL2 needed!");
      throw new Error("WebGL2 not supported!");
    }

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, fragShaderSource) {
      const vsSource = `#version 300 es
        in vec4 position;
        void main() { gl_Position = position; }`;
      const fsSource = fragShaderSource;

      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const fragShaderSource = document.getElementById('fragment-shader').textContent;

    glContexts.forEach(gl => {
      const program = createProgram(gl, fragShaderSource);
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1,
      ]), gl.STATIC_DRAW);

      const positionLoc = gl.getAttribLocation(program, "position");

      function draw(time) {
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.useProgram(program);

        const uTime = gl.getUniformLocation(program, "uTime");
        gl.uniform1f(uTime, time * 0.001);

        gl.enableVertexAttribArray(positionLoc);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    });

    // MULTICORE CPU ABUSE
    const wasmCode = new Uint8Array([
      0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x0a,0x02,0x60,0x00,0x00,0x60,0x01,0x7f,0x00,
      0x03,0x03,0x02,0x00,0x01,0x07,0x07,0x01,0x03,0x6c,0x6f,0x6f,0x00,0x00,0x0a,0x0b,0x02,0x04,
      0x00,0x41,0x00,0x0b,0x05,0x00,0x41,0x01,0x0b
    ]);
    const wasmModule = new WebAssembly.Module(wasmCode);
    const wasmInstance = new WebAssembly.Instance(wasmModule);

    function infiniteCPU() {
      while (true) wasmInstance.exports.loo();
    }

    function stressAllCores() {
      const cores = navigator.hardwareConcurrency || 4;
      for (let i = 0; i < cores * 2; i++) {
        const worker = new Worker(URL.createObjectURL(new Blob([`
          const wasmCode = new Uint8Array([${wasmCode.join(',')}]);
          WebAssembly.instantiate(wasmCode).then(obj => {
            while(true) obj.instance.exports.loo();
          });
        `], { type: 'application/javascript' })));
      }
    }
    setTimeout(stressAllCores, 1000);
    setTimeout(infiniteCPU, 3000);

    // MEMORY FLOOD
    setInterval(() => {
      let hugeArray = new Float64Array(10**7);
      for (let i = 0; i < hugeArray.length; i++) {
        hugeArray[i] = Math.random();
      }
    }, 500);

  </script>
</body>
</html>
